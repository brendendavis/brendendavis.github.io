

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Surreal Astral Art Gallery</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: black; }
    canvas { display: block; }
    /* Start Screen Styles */
    #start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    #start-screen h1 {
      font-size: 4em;
      color: white;
      text-shadow: 2px 2px 8px #00ffff, -2px -2px 8px #ff00ff;
      margin: 0;
      /* Apply combined 3D perspective, rotation, and floating effect */
      animation: floatRotate 5s ease-in-out infinite;
    }

    @keyframes floatRotate {
      0% {
        transform: perspective(600px) rotateX(15deg) rotateY(0deg) translateY(0);
      }
      50% {
        transform: perspective(600px) rotateX(15deg) rotateY(20deg) translateY(-20px);
      }
      100% {
        transform: perspective(600px) rotateX(15deg) rotateY(0deg) translateY(0);
      }
    }

    #start-screen button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 1.5em;
      cursor: pointer;
      background-color: #222;
      color: white;
      border: 2px solid white;
      border-radius: 8px;
      transition: background-color 0.3s;
    }

    #start-screen button:hover {
      background-color: #444;
    }
    /* Stage Mask and Dialogue Styles */
    #mask-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 20px;
    }
    #mask-container img {
      width: 150px;
      animation: maskMouth 3s ease-in-out infinite;
    }
    @keyframes maskMouth {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }
    /* Updated Dialogue Box Style */
    .dialogue-box {
      background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(50,50,50,0.8));
      padding: 15px 25px;
      border-radius: 15px;
      color: #00ffff;
      font-size: 1.2em;
      margin-top: 10px;
      font-family: 'Courier New', monospace;
      border: 2px solid #00ffff;
      box-shadow: 0 0 10px rgba(0,255,255,0.5);
      position: relative;
      overflow: hidden;
      /* Allow text wrapping */
      white-space: normal;
      max-width: 80vw;
      max-height: 30vh;
    }
    /* Blinking Cursor Style */
    .cursor {
      display: inline-block;
      width: 10px;
      background-color: #00ffff;
      margin-left: 5px;
      animation: blink 1s step-end infinite;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }
  </style>
</head>
<body>
  <!-- Updated Start Screen HTML -->
  <div id="start-screen">
    <h1>unReality Gallery</h1>
    <div id="mask-container">
      <img src="./mask.gif" alt="Stage Mask" id="mask-image">
      <div class="dialogue-box">Hello. This is unReality Gallery — where the familiar unravels into a dreamscape of abstraction and raw emotion. This space was manifested by Brenden Davis, whose art redefines identity and the intricacies of the subjective experience, every piece here challenges the boundaries of perception. Would you like to enter?</div>
    </div>
    <button id="enter-button">Enter?</button>
  </div>
  <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/",
        "dat.gui": "https://unpkg.com/dat.gui@0.7.9/build/dat.gui.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { GUI } from 'dat.gui';
    
    import { HalftonePass } from 'three/addons/postprocessing/HalftonePass.js';
    import { Reflector } from 'three/addons/objects/Reflector.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
    
    // Browser detection and logging
    const userAgent = navigator.userAgent;
    console.log('Browser Info:', {
      userAgent: userAgent,
      isOculusBrowser: /OculusBrowser/.test(userAgent),
      isWolvic: /Wolvic/.test(userAgent),
      isWebXRSupported: 'xr' in navigator,
      isImmersiveVrSupported: 'xr' in navigator ? navigator.xr.isSessionSupported('immersive-vr') : false
    });

    // Detect low-performing devices (e.g., OculusBrowser or small viewport)
    const isLowPerformance = /OculusBrowser/.test(navigator.userAgent) || window.innerWidth < 800;
    
    const BlurShader = {
      uniforms: {
        tDiffuse: { value: null },
        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        blurAmount: { value: 0.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float blurAmount;
        varying vec2 vUv;
        
        void main() {
          vec4 sum = vec4(0.0);
          float offset = blurAmount / resolution.x;
          sum += texture2D(tDiffuse, vUv + vec2(-offset, -offset));
          sum += texture2D(tDiffuse, vUv + vec2(-offset, offset));
          sum += texture2D(tDiffuse, vUv + vec2(offset, -offset));
          sum += texture2D(tDiffuse, vUv + vec2(offset, offset));
          gl_FragColor = sum * 0.25;
        }
      `
    };
    
    const blurPass = new ShaderPass(BlurShader);

    // Scene, camera, renderer setup
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.002);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 30); // Position regular camera at the start position
    const vrCamera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    vrCamera.position.set(0, 0, 0); // Position VR camera in the center of the gallery
    const raycaster = new THREE.Raycaster();
let focusedPanel = null;
let currentPosition = new THREE.Vector3();
let lastPosition = new THREE.Vector3();
    // --- Audio Setup ---
    const listener = new THREE.AudioListener();
    camera.add(listener);
    
    const ambientSound = new THREE.Audio(listener);
    const audioLoader = new THREE.AudioLoader();
    
    // Load an ambient audio file (ensure the file is in your project directory)
    audioLoader.load('./ambient.mp3', function(buffer) {
      ambientSound.setBuffer(buffer);
      ambientSound.setLoop(true);
      ambientSound.setVolume(0.9);
      // Do not auto-play; wait for user interaction
    });
    // -------------------
    
    // Start Screen Handling
    const startScreen = document.getElementById('start-screen');
    const enterButton = document.getElementById('enter-button');

    // Variables for transition animation
    let transitionActive = false;
    let transitionStartTime = 0;
    const transitionDuration = 3; // duration in seconds
    const initialFov = 100;
    const targetFov = 70;
    const initialCameraPosition = new THREE.Vector3();
    const targetCameraPosition = new THREE.Vector3();
    
    // Set up a clock for animations
    const clock = new THREE.Clock();

    enterButton.addEventListener('click', () => {
      // Hide the start screen overlay
      startScreen.style.display = 'none';
      // Resume AudioContext if necessary and play ambient audio
      if (listener.context.state === 'suspended') {
        listener.context.resume();
      }
      if (!ambientSound.isPlaying) {
        ambientSound.play();
      }

      // Start transition animation:
      transitionActive = true;
      transitionStartTime = clock.getElapsedTime();

      // Set a fixed target camera position for a consistent transition
      targetCameraPosition.set(0, 0, 30);

      // Set initial camera position far away from target (simulate warp speed)
      // Here we offset the target along the negative Z direction by 100 units.
      initialCameraPosition.copy(targetCameraPosition).add(new THREE.Vector3(0, 0, -100));

      // Set the camera to the initial state for the transition:
      camera.position.copy(initialCameraPosition);
      camera.fov = initialFov;
      camera.updateProjectionMatrix();
    });
    // Typing effect for dialogue: display one sentence at a time with a "Next" button.
    const dialogueBox = document.querySelector('.dialogue-box');

    // Define the sentences (split your dialogue text manually)
    const dialogueSentences = [
      "Hello. This is unReality Gallery—where the familiar unravels into a dreamscape of abstraction and raw emotion.",
      "This space was manifested by Brenden Davis, whose art redefines identity and the intricacies of the subjective experience.",
      "Every piece here challenges the boundaries of perception.",
      "Would you like to enter?"
    ];

    let currentSentence = 0;

    function typeSentence(sentence, callback) {
      dialogueBox.innerHTML = ""; // clear current text
      let index = 0;
      function typeChar() {
        if (index < sentence.length) {
          dialogueBox.innerHTML += sentence.charAt(index);
          index++;
          setTimeout(typeChar, 50); // typing speed (adjust as needed)
        } else {
          // After finishing the sentence, add blinking cursor
          const cursorSpan = document.createElement('span');
          cursorSpan.classList.add('cursor');
          cursorSpan.textContent = '|';
          dialogueBox.appendChild(cursorSpan);

          // If there is a next sentence, add a "Next" button
          if (currentSentence < dialogueSentences.length - 1) {
            const nextButton = document.createElement('button');
            nextButton.textContent = "Next";
            nextButton.style.marginLeft = "10px";
            nextButton.style.padding = "5px 10px";
            nextButton.style.fontSize = "1em";
            nextButton.addEventListener('click', () => {
              currentSentence++;
              typeSentence(dialogueSentences[currentSentence]);
            });
            dialogueBox.appendChild(document.createElement('br'));
            dialogueBox.appendChild(nextButton);
          }
          if (callback) callback();
        }
      }
      typeChar();
    }

    // Start typing the first sentence
    typeSentence(dialogueSentences[currentSentence]);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.xr.enabled = true;
    renderer.setSize(window.innerWidth, window.innerHeight);
    // Reduce pixel ratio on low-performance devices
    renderer.setPixelRatio(isLowPerformance ? 1 : window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // VR-specific variables
    let xrReferenceSpace = null;
    let session = null;
    const controllerModelFactory = new XRControllerModelFactory();
    
    // Hand tracking variables
    let handTrackingSupported = false;
    const handJoints = {
      left: new Map(),
      right: new Map()
    };
    
    // Set up VR controllers for interaction
    const controller1 = renderer.xr.getController(0);
    const controller2 = renderer.xr.getController(1);
    scene.add(controller1);
    scene.add(controller2);
    
    // Add controller grip models for visualization
    const controllerGrip1 = renderer.xr.getControllerGrip(0);
    const controllerGrip2 = renderer.xr.getControllerGrip(1);
    controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
    controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
    scene.add(controllerGrip1);
    scene.add(controllerGrip2);
    function createControllerRay() {
  const material = new THREE.LineBasicMaterial({ color: 0xffffff });
  const geometry = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, 0),
    new THREE.Vector3(0, 0, -1)
  ]);
  const line = new THREE.Line(geometry, material);
  line.name = 'controllerRay';
  line.scale.z = 10; // Extend the ray to 10 units
  return line;
}
controller1.add(createControllerRay());
controller2.add(createControllerRay());
    
    // Create hand tracking visualization
    function createHandMesh() {
      const geometry = new THREE.SphereGeometry(0.01, 8, 8);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      return new THREE.Mesh(geometry, material);
    }
    
    // Check WebXR support with detailed logging
    if ('xr' in navigator) {
      navigator.xr.isSessionSupported('immersive-vr').then(supported => {
        console.log('WebXR Support Check:', {
          supported: supported,
          features: supported ? navigator.xr.getSupportedFeatures() : [],
          optionalFeatures: supported ? navigator.xr.getOptionalFeatures() : []
        });

        if (supported) {
          console.log('WebXR VR is supported');
          const vrButton = VRButton.createButton(renderer, {
            requiredFeatures: ['local-floor'],
            optionalFeatures: ['hand-tracking'],
            sessionInit: {
              optionalFeatures: ['local-floor', 'hand-tracking']
            }
          });
          document.body.appendChild(vrButton);
        } else {
          console.warn('WebXR VR is not supported on this device/browser');
          // Show a message to the user
          const warningDiv = document.createElement('div');
          warningDiv.style.position = 'fixed';
          warningDiv.style.bottom = '10px';
          warningDiv.style.left = '10px';
          warningDiv.style.color = 'white';
          warningDiv.style.background = 'rgba(0,0,0,0.5)';
          warningDiv.style.padding = '10px';
          warningDiv.style.borderRadius = '5px';
          warningDiv.textContent = 'VR not supported on this device/browser';
          document.body.appendChild(warningDiv);
        }
      }).catch(err => {
        console.error('Error checking VR support:', err);
      });
    } else {
      console.warn('WebXR API is not available in this browser');
    }

    // Handle XR session start
    renderer.xr.addEventListener('sessionstart', async function() {
  console.log('VR session starting...');
  session = renderer.xr.getSession();

  // Add a slight delay before adding the UI elements to ensure fully ready.
  setTimeout(() => {
  scene.add(exitButton);
  scene.add(recenterButton);
  console.log('UI buttons added to the scene near the title.');
}, 500);
      
      try {
        // Request hand tracking support
        if (session.inputSources.length > 0) {
          console.log('Input sources available:', session.inputSources.length);
          const inputSource = session.inputSources[0];
          if (inputSource.hand) {
            handTrackingSupported = true;
            console.log('Hand tracking is supported');
            
            // Create hand tracking visualization
            for (let i = 0; i < 25; i++) {
              handJoints.left.set(i, createHandMesh());
              handJoints.right.set(i, createHandMesh());
              scene.add(handJoints.left.get(i));
              scene.add(handJoints.right.get(i));
            }
          }
        }
        
        console.log('Requesting local-floor reference space...');
        xrReferenceSpace = await session.requestReferenceSpace('local-floor');
        console.log('XR reference space acquired');
        
        // Disable orbit controls in VR mode
        controls.enabled = false;
        
        // Log available input sources
        console.log('Available input sources:', session.inputSources);
        session.inputSources.forEach((source, index) => {
          console.log(`Input source ${index}:`, {
            handedness: source.handedness,
            targetRayMode: source.targetRayMode,
            gamepad: source.gamepad ? {
              axes: source.gamepad.axes.length,
              buttons: source.gamepad.buttons.length
            } : 'none',
            hand: source.hand ? 'supported' : 'not supported'
          });
        });
        
        // Reset VR camera position
        if (xrReferenceSpace) {
          console.log('Resetting VR camera position...');
          const resetTransform = new XRRigidTransform({x: 0, y: 1.6, z: 0});
          xrReferenceSpace = xrReferenceSpace.getOffsetReferenceSpace(resetTransform);
          console.log('VR camera position reset complete');
        }
      } catch (error) {
        console.error('Error during VR session start:', error);
        try {
          console.log('Falling back to local reference space...');
          xrReferenceSpace = await session.requestReferenceSpace('local');
          console.log('Local reference space acquired');
        } catch (fallbackError) {
          console.error('Error requesting fallback reference space:', fallbackError);
        }
      }
    });
    
    // Handle XR session end
    renderer.xr.addEventListener('sessionend', function() {
      console.log('VR session ending...');
      const xrCam = renderer.xr.getCamera(camera);
      scene.remove(exitButton);
scene.remove(recenterButton);
      session = null;
      xrReferenceSpace = null;
      handTrackingSupported = false;
      // Remove hand tracking visualization
      handJoints.left.forEach(mesh => scene.remove(mesh));
      handJoints.right.forEach(mesh => scene.remove(mesh));
      handJoints.left.clear();
      handJoints.right.clear();
      // Re-enable orbit controls when exiting VR
      controls.enabled = true;
    });
    
    // Handle XR session error
    renderer.xr.addEventListener('sessionerror', function(event) {
      console.error('VR session error:', event);
    });
    
    const tempMatrix = new THREE.Matrix4();
    
    // Updated controller event handlers for Meta Quest 2
    function onSelect(event) {
      const controller = event.target;
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      
      const exitIntersect = raycaster.intersectObject(exitButton);
      if (exitIntersect.length > 0) {
          console.log('Exit button selected');
          if (session) {
              session.end();
              return;
          }
      }
      const recenterIntersect = raycaster.intersectObject(recenterButton);
      if (recenterIntersect.length > 0) {
          console.log('Recenter button selected');
          if (xrReferenceSpace && session) {
              const resetTransform = new XRRigidTransform({ x: 0, y: 1.6, z: 0 });
              xrReferenceSpace = xrReferenceSpace.getOffsetReferenceSpace(resetTransform);
              return;
          }
      }
      
      console.log('Controller select event fired', event);
      const intersects = raycaster.intersectObjects(galleryGroup.children);
      if (intersects.length > 0) {
        focusedPanel = intersects[0].object;
        // Set the orbit controls target to the focused panel
        controls.target.copy(focusedPanel.position);
        
        // Trigger haptic feedback if available
        triggerHapticFeedback(controller);
      if (renderer.xr.isPresenting) {
          const xrCamera = renderer.xr.getCamera(camera);
          const targetPosition = new THREE.Vector3(focusedPanel.position.x, focusedPanel.position.y, focusedPanel.position.z + 10);
          const delta = new THREE.Vector3().subVectors(targetPosition, xrCamera.position);
          // Instead of moving the scene, update the XR reference space offset
          const transform = new XRRigidTransform({ x: delta.x, y: delta.y, z: delta.z });
          xrReferenceSpace = xrReferenceSpace.getOffsetReferenceSpace(transform);
          focusedPanel = null;
      }
      }
    }
    
    function onSqueeze(event) {
      console.log('Controller squeeze event fired', event);
      // Reset position or perform other grip actions
      if (xrReferenceSpace) {
        // Reset position to center of gallery
        const resetTransform = new XRRigidTransform({x: 0, y: 1.6, z: 0});
        xrReferenceSpace = xrReferenceSpace.getOffsetReferenceSpace(resetTransform);
      }
    }
    
    // Haptic feedback function
    function triggerHapticFeedback(controller, intensity = 0.7, duration = 100) {
      if (!session) return;
      
      // Find the input source associated with this controller
      const inputSources = session.inputSources;
      for (let i = 0; i < inputSources.length; i++) {
        const inputSource = inputSources[i];
        const controllerIndex = controller === renderer.xr.getController(0) ? 0 : 1;
        
        if (i === controllerIndex && inputSource.gamepad && inputSource.gamepad.hapticActuators && inputSource.gamepad.hapticActuators.length > 0) {
          console.log('Triggering haptic feedback');
          inputSource.gamepad.hapticActuators[0].pulse(intensity, duration);
          return;
        }
      }
    }
    
    // Add initial event listeners to controllers
    controller1.addEventListener('select', onSelect);
    controller1.addEventListener('squeezestart', onSqueeze);
    controller2.addEventListener('select', onSelect);
    controller2.addEventListener('squeezestart', onSqueeze);
    
    // OrbitControls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- Dynamic Ambient Particle Effects (Cosmic Dust) ---
    // Reduce particle count on low-performance devices
    const ambientParticleCount = isLowPerformance ? 200 : 500;
    const ambientGeometry = new THREE.BufferGeometry();
    const ambientPositions = new Float32Array(ambientParticleCount * 3);
    for (let i = 0; i < ambientParticleCount; i++) {
      ambientPositions[i * 3] = (Math.random() - 0.5) * 200;
      ambientPositions[i * 3 + 1] = (Math.random() - 0.5) * 200;
      ambientPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;
    }
    ambientGeometry.setAttribute('position', new THREE.BufferAttribute(ambientPositions, 3));
    const ambientMaterial = new THREE.PointsMaterial({
      color: 0xffddaa,
      size: 1,
      blending: THREE.AdditiveBlending,
      transparent: true,
      opacity: 0.5,
      depthWrite: false
    });
    const ambientParticles = new THREE.Points(ambientGeometry, ambientMaterial);
    scene.add(ambientParticles);

    // --- Sun for God Rays ---
    const sunGeometry = new THREE.SphereGeometry(5, 32, 32);
    const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffffee });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    sun.position.set(0, 50, -50);
    scene.add(sun);

    let composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    if (isLowPerformance) {
      const VignetteShader = {
        uniforms: {
          tDiffuse: { value: null },
          offset: { value: 1.0 },
          darkness: { value: 1.1 }
        },
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
          }
        `,
        fragmentShader: `
          uniform sampler2D tDiffuse;
          uniform float offset;
          uniform float darkness;
          varying vec2 vUv;
          
          void main() {
            vec4 color = texture2D( tDiffuse, vUv );
            vec2 uv = (vUv - vec2(0.5)) * vec2(offset);
            float vignette = smoothstep(0.8, 1.0, length(uv));
            color.rgb = mix( color.rgb, color.rgb * (1.0 - darkness), vignette );
            gl_FragColor = color;
          }
        `
      };
      const vignettePass = new ShaderPass(VignetteShader);
      composer.addPass(vignettePass);
    } else {
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.8,
        0.2,
        0.9
      );
      composer.addPass(bloomPass);
    }


    // Responsive canvas on resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    // Dynamic skybox with a shader material
    const skyboxShader = {
      uniforms: {
        time: { value: 0.0 }
      },
      vertexShader: `
        varying vec3 vWorldPosition;
        void main() {
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        varying vec3 vWorldPosition;
        float random(vec3 scale, float seed) {
          return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
        }
        void main() {
          vec3 dir = normalize(vWorldPosition);
          float r = 0.3 + 0.7 * random(vec3(12.9898, 78.233, 151.7182), time * 0.1);
          float g = 0.1 + 0.3 * random(vec3(63.7264, 10.873, 623.6736), time * 0.1);
          float b = 0.4 + 0.6 * random(vec3(34.8712, 76.3421, 54.5723), time * 0.1);
          gl_FragColor = vec4(r * (dir.x * 0.5 + 0.5), g * (dir.y * 0.5 + 0.5), b * (dir.z * 0.5 + 0.5), 1.0);
        }
      `
    };
    const skyboxMaterial = new THREE.ShaderMaterial({
      uniforms: THREE.UniformsUtils.clone(skyboxShader.uniforms),
      vertexShader: skyboxShader.vertexShader,
      fragmentShader: skyboxShader.fragmentShader,
      side: THREE.BackSide
    });
    const skybox = new THREE.Mesh(new THREE.BoxGeometry(900, 900, 900), skyboxMaterial);
    scene.add(skybox);
    
    // --- Reflective Floor ---
    const floorGeometry = new THREE.PlaneGeometry(200, 200);
    const floorReflector = new Reflector(floorGeometry, {
      clipBias: 0.003,
      textureWidth: window.innerWidth * window.devicePixelRatio,
      textureHeight: window.innerHeight * window.devicePixelRatio,
      color: 0x777777
    });
    floorReflector.rotateX(-Math.PI / 2);
    floorReflector.position.y = -8; // Adjust the vertical position as needed
    scene.add(floorReflector);
    // -----------------------

    // --- Add Star Field to the Background ---
    const starsGeometry = new THREE.BufferGeometry();
    const starCount = 1000;
    const positions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const radius = 100 + Math.random() * 50;
      positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
      positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      positions[i * 3 + 2] = radius * Math.cos(phi);
    }
    starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);
    // --- Floating Title in the Stars ---
    const fontLoader = new FontLoader();
    fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.157.0/examples/fonts/helvetiker_regular.typeface.json', function(font) {
      const textGeometry = new TextGeometry('Brenden Davis : unReality Gallery', {
    font: font,
    size: 3,
    height: 0.5,
    curveSegments: 12,
    bevelEnabled: true,
    bevelThickness: 0.03,
    bevelSize: 0.02,
    bevelOffset: 0,
    bevelSegments: 5
}); 
      const textMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const textMesh = new THREE.Mesh(textGeometry, textMaterial);
      textMesh.position.set(-15, 30, -100);
      textMesh.rotation.y = Math.PI / 4;
      scene.add(textMesh);
    });
    // -------------------------------

    // --- Astral Art Gallery Setup ---
    // Create a group for the gallery and load multiple image panels
    const textureLoader = new THREE.TextureLoader();
    const galleryImages = [
      './image1.png',
      './image2.png',
      './image3.png',
      './image4.png',
      './image5.png',
      './image6.png',
      './image7.png',
      './image8.png',
      './image9.png',
      './image10.png',
      './image11.png',
      './image12.png',
      './image13.jpeg'
    ];

    const galleryGroup = new THREE.Group();
    const numImages = galleryImages.length;
    const galleryRadius = 20;
    galleryImages.forEach((imgPath, index) => {
  const angle = (index / numImages) * Math.PI * 2;
  const x = galleryRadius * Math.cos(angle);
  const z = galleryRadius * Math.sin(angle);
  const texture = textureLoader.load(imgPath);
  // Use a subdivided plane for smoother displacement; use fewer segments on low-performing devices
  const panelGeometry = new THREE.PlaneGeometry(8, 5, isLowPerformance ? 10 : 50, isLowPerformance ? 10 : 50);
  const panelMaterial = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0 },
      map: { value: texture }
    },
    vertexShader: `
        uniform float time;
        varying vec2 vUv;
        void main() {
            vUv = uv;
            vec3 pos = position;
            // Apply a gentle wave displacement
            float wave = sin(pos.x * 1.0 + time) * 0.1 + cos(pos.y * 2.0 + time) * 0.1;
            pos.z += wave;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D map;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D(map, vUv);
            if(color.a < 0.1) discard;
            gl_FragColor = color;
        }
    `,
    side: THREE.DoubleSide,
    transparent: true,
    alphaTest: 0.5
  });
  
  // Create a mesh for the panel
  const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
  // Position the panel along the circle
  panelMesh.position.set(x, 0, z);
  // Rotate the panel to face the center of the gallery
  panelMesh.lookAt(new THREE.Vector3(0, 0, 0));
  
  // Add the panel mesh to the gallery group
  galleryGroup.add(panelMesh);
});

// Ensure the gallery group is added to the scene
scene.add(galleryGroup);
renderer.domElement.addEventListener('click', onCanvasClick, false);
function onCanvasClick(event) {
  // Get canvas bounding rectangle for accurate mouse coordinates
  const rect = renderer.domElement.getBoundingClientRect();
  const mouse = new THREE.Vector2(
    ((event.clientX - rect.left) / rect.width) * 2 - 1,
    -((event.clientY - rect.top) / rect.height) * 2 + 1
  );
  
  // Update the raycaster using the mouse coordinates and the camera
  raycaster.setFromCamera(mouse, camera);
  
  // Check for intersections with the gallery image panels
  const intersects = raycaster.intersectObjects(galleryGroup.children);
  if (intersects.length > 0) {
    focusedPanel = intersects[0].object;
  }
}
    function updateVRControls(deltaTime) {
      if (!session) return;
      const rotationSpeed = 1.0; // adjust rotation speed as needed
      session.inputSources.forEach(source => {
        if (source.gamepad && source.gamepad.axes.length > 0) {
          let horizontal = source.gamepad.axes[0];
          if (Math.abs(horizontal) > 0.2) { // deadzone threshold
            galleryGroup.rotation.y += horizontal * rotationSpeed * deltaTime;
          }
        }
      });
    }

    // Animation loop
    function animate(time, frame) {
      const deltaTime = clock.getDelta();
      const moveSpeed = 1; // adjust this value as needed
      let headPose;
      if (frame && xrReferenceSpace) {
        const viewerPose = frame.getViewerPose(xrReferenceSpace);
        if (viewerPose) {
          headPose = viewerPose.views[0];
        }
      }
      const elapsed = clock.getElapsedTime();
      const params = { cameraTravelSpeed: 0.05 };

      // Update VR controls if in VR mode
      if (renderer.xr.isPresenting) {
        updateVRControls(deltaTime);
      } else {
        // Only update orbit controls when not in VR
        controls.update();
      }

      // Update ambient particle positions for a drifting effect
      const ambientPositionsArray = ambientGeometry.attributes.position.array;
      for (let i = 0; i < ambientPositionsArray.length; i += 3) {
        ambientPositionsArray[i + 1] += 0.001; // drift upward
        if (ambientPositionsArray[i + 1] > 100) {
          ambientPositionsArray[i + 1] = -100;
        }
      }
      ambientGeometry.attributes.position.needsUpdate = true;

      // Update the shader uniform for displacement effect
      galleryGroup.children.forEach(panel => {
        panel.material.uniforms.time.value = elapsed;
      });

      // Animate the dynamic skybox
      skyboxMaterial.uniforms.time.value = elapsed * 0.5;

      // Slowly rotate the gallery for a surreal effect
      galleryGroup.rotation.y += 0.001;

      if (transitionActive) {
        // Calculate transition progress (0 to 1)
        const t = (clock.getElapsedTime() - transitionStartTime) / transitionDuration;
        const progress = Math.min(t, 1);
        // Ease-out interpolation (easeOutQuad: 1 - (1-x)^2)
        const easeProgress = 1 - Math.pow(1 - progress, 2);

        // Interpolate camera position and FOV from initial to target values
        camera.position.lerpVectors(initialCameraPosition, targetCameraPosition, easeProgress);
        camera.fov = initialFov + (targetFov - initialFov) * easeProgress;
        camera.updateProjectionMatrix();
        camera.lookAt(new THREE.Vector3(0, 0, 0));
        // Update blur effect during transition (max blur at mid-transition)
        blurPass.uniforms.blurAmount.value = Math.sin(easeProgress * Math.PI) * 5.0;
        // Dynamically adjust ambient particle size for additional effect
        ambientMaterial.size = 1 + 2 * Math.sin(easeProgress * Math.PI);

        // End transition when progress is complete
        if (progress >= 1) {
          transitionActive = false;
        }
      } else if (focusedPanel && !renderer.xr.isPresenting) {
        // Normal behavior when an image is focused (only in non-VR mode)
        const targetPosition = new THREE.Vector3(focusedPanel.position.x, focusedPanel.position.y, focusedPanel.position.z + 10);
        camera.position.lerp(targetPosition, params.cameraTravelSpeed);
        camera.lookAt(focusedPanel.position);
      } else if (focusedPanel && !renderer.xr.isPresenting) {
        // Normal behavior when an image is focused (only in non-VR mode)
        const targetPosition = new THREE.Vector3(focusedPanel.position.x, focusedPanel.position.y, focusedPanel.position.z + 10);
        camera.position.lerp(targetPosition, params.cameraTravelSpeed);
        camera.lookAt(focusedPanel.position);
      }

      if (!transitionActive) {
        blurPass.uniforms.blurAmount.value = 0;
      }

      // Render the scene
      if (!renderer.xr.isPresenting && composer) {
        composer.render();
      } else {
        renderer.render(scene, camera);
      }
    }

    // Explicit UI element for starting immersive VR
    const vrButtonExplicit = document.getElementById('enter-vr-button');
    vrButtonExplicit.addEventListener('click', async () => {
      if (navigator.xr) {
        try {
          const supported = await navigator.xr.isSessionSupported('immersive-vr');
          if (supported) {
            const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'hand-tracking'] });
            renderer.xr.setSession(session);
          } else {
            alert('Immersive VR is not supported on this device/browser.');
          }
        } catch (e) {
          console.error('Error starting VR session:', e);
        }
      } else {
        alert('WebXR is not available in this browser.');
      }
    });
    // Helper function to create a text sprite for button labels
    function createTextSprite(message, scale) {
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 128;
      const context = canvas.getContext('2d');
      // Clear the canvas with a transparent background
      context.fillStyle = 'rgba(0, 0, 0, 0)';
      context.fillRect(0, 0, canvas.width, canvas.height);
      // Set text properties
      context.font = '48px Arial';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(message, canvas.width / 2, canvas.height / 2);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(spriteMaterial);
      sprite.scale.set(scale.x, scale.y, 1);
      return sprite;
    }
    
    // Create smaller, dark grey, translucent exit button
    const exitButtonGeometry = new THREE.PlaneGeometry(0.8, 0.4);
    const exitButtonMaterial = new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.7 });
    const exitButton = new THREE.Mesh(exitButtonGeometry, exitButtonMaterial);
    exitButton.position.set(-0.5, 0.5, -2);
    exitButton.name = 'exitButton';
    // Add label to the exit button
    const exitLabel = createTextSprite('Exit', { x: 0.7, y: 0.3 });
    exitLabel.position.set(0, 0, 0.01);
    exitButton.add(exitLabel);
    
    // Create smaller, dark grey, translucent recenter button
    const recenterButtonGeometry = new THREE.PlaneGeometry(0.8, 0.4);
    const recenterButtonMaterial = new THREE.MeshBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.7 });
    const recenterButton = new THREE.Mesh(recenterButtonGeometry, recenterButtonMaterial);
    recenterButton.position.set(0.5, 0.5, -2);
    recenterButton.name = 'recenterButton';
    // Add label to the recenter button
    const recenterLabel = createTextSprite('Recenter', { x: 0.7, y: 0.3 });
    recenterLabel.position.set(0, 0, 0.01);
    recenterButton.add(recenterLabel);
    
    const uiContainer = new THREE.Group();
    uiContainer.add(exitButton);
    uiContainer.add(recenterButton);
    
    // Parent the UI container to the camera so it stays in view during VR
    camera.add(uiContainer);
    renderer.setAnimationLoop(animate);
  </script>
<button id="enter-vr-button" style="position: fixed; bottom: 20px; right: 20px; padding: 10px 20px; font-size: 1.2em; z-index: 2000;">Enter Immersive VR</button>
</body>
</html>